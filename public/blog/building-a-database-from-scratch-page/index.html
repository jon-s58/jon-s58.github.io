<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Building a Database From Scratch - Storage Layer Page Design - Jonathan Sarig</title>
    <meta name="description" content="Personal site of Jonathan Sarig, a software engineer working in Go, Rust, and Python. Projects, blog, and contact.">
    <link rel="canonical" href="https:&#x2F;&#x2F;jon-s58.github.io&#x2F;blog&#x2F;building-a-database-from-scratch-page&#x2F;">
    <link rel="stylesheet" href="https://jon-s58.github.io/style.css?v=2">
    <meta property="og:title" content="Jonathan Sarig — Software Engineer">
    <meta property="og:description" content="Projects, blog, and contact.">
    <meta property="og:url" content="https:&#x2F;&#x2F;jon-s58.github.io&#x2F;blog&#x2F;building-a-database-from-scratch-page&#x2F;">
    <meta name="twitter:card" content="summary">
    
</head>
<body>
    <header>
        <nav>
            <div class="nav-container">
                <ul class="nav-menu">
                    <li><a href="/" >About Jonathan Sarig</a></li>
                    <li><a href="/blog" >Blog</a></li>
                    <li><a href="/projects" >Projects</a></li>
                    <li><a href="/cv" >Resume</a></li>
                </ul>
                <div class="nav-social">
                    <a href="https:&#x2F;&#x2F;github.com&#x2F;jon-s58" target="_blank" rel="noopener" class="nav-social-link" title="GitHub">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/>
                        </svg>
                    </a>
                    <a href="https:&#x2F;&#x2F;linkedin.com&#x2F;in&#x2F;jonathan-sarig" target="_blank" rel="noopener" class="nav-social-link" title="LinkedIn">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M19 0h-14c-2.761 0-5 2.239-5 5v14c0 2.761 2.239 5 5 5h14c2.762 0 5-2.239 5-5v-14c0-2.761-2.238-5-5-5zm-11 19h-3v-11h3v11zm-1.5-12.268c-.966 0-1.75-.79-1.75-1.764s.784-1.764 1.75-1.764 1.75.79 1.75 1.764-.783 1.764-1.75 1.764zm13.5 12.268h-3v-5.604c0-3.368-4-3.113-4 0v5.604h-3v-11h3v1.765c1.396-2.586 7-2.777 7 2.476v6.759z"/>
                        </svg>
                    </a>
                </div>
            </div>
        </nav>
    </header>

    <main>
        
<article class="blog-post">
    <div class="container">
        <header class="post-header">
            <h1>Building a Database From Scratch - Storage Layer Page Design</h1>
            <div class="blog-meta">
                <time datetime="2025-12-11">December 11, 2025</time>
                
                
                <span class="tags">
                    
                    <span class="tag">Rust</span>
                    
                    <span class="tag">Database</span>
                    
                    <span class="tag">Storage Layer</span>
                    
                </span>
                
            </div>
        </header>
        
        <div class="post-content">
            <h2 id="the-storage-layer">The Storage Layer</h2>
<p>Kicking off this series, we begin with the <strong>Storage Layer</strong> - the part of the database responsible for storing the data on disk, indexing, and everything else related.</p>
<p>Have you ever wondered how your records are being stored? What does a row mean to the computer? Is everything on RAM? On disk? How is it more efficient than just storing the raw data on files?</p>
<p>In this blog piece I will dive into the interface between raw data on files (binary) and actual records and tables. The basic unit of this interface is called a <strong>Page</strong>.</p>
<h2 id="what-are-pages">What are Pages?</h2>
<p>The basic unit of the storage layer is the <strong>Page</strong>. What are pages and why do they matter?</p>
<p>Databases usually don't read/write individual bytes - they work with <strong>fixed-size blocks</strong> because operating systems and hardware are optimized for block I/O. Pages are an implementation of these blocks.</p>
<h3 id="why-pages-matter">Why Pages Matter</h3>
<p>Pages provide:</p>
<ul>
<li><strong>Efficient disk I/O</strong> - The cost of reading a single byte is almost the same as reading 4-8KB</li>
<li><strong>Better cache locality</strong> - Data that's accessed together stays together</li>
<li><strong>Simplified buffer management</strong> - Fixed-size chunks are easier to manage in memory</li>
<li><strong>Atomic write units</strong> - Essential for crash recovery</li>
</ul>
<h2 id="choosing-the-right-page-size">Choosing the Right Page Size</h2>
<p>What is the size of these fixed sized blocks? It can be anything we want but to leverage the operating system memory reading we need a number that is a power of 2 ideally between 4 and 16 KB.</p>
<p>Different databases have made different choices:</p>
<ul>
<li><strong>PostgreSQL</strong>: 8KB</li>
<li><strong>MySQL InnoDB</strong>: 16KB</li>
<li><strong>SQLite</strong>: 4KB (default)</li>
</ul>
<h3 id="trade-offs">Trade-offs</h3>
<p><strong>Larger pages:</strong></p>
<ul>
<li>Better sequential scan performance</li>
<li>Fewer I/O operations</li>
<li>Can waste space for small records</li>
</ul>
<p><strong>Smaller pages:</strong></p>
<ul>
<li>Less wasted space</li>
<li>Better for random access patterns</li>
<li>More I/O operations needed</li>
</ul>
<h3 id="my-choice-8kb">My Choice: 8KB</h3>
<p>I chose <strong>8KB</strong> because:</p>
<ul>
<li>Used by many successful databases like PostgreSQL</li>
<li>Works well with most operating and file systems</li>
<li>I can easily change it later so no reason to waste time right now</li>
</ul>
<h2 id="page-anatomy">Page Anatomy</h2>
<p>What are the components of a page?</p>
<h3 id="the-page-header">The Page Header</h3>
<p>Header is a section in the beginning of each page holding relevant data about the records inside it, data integrity, free space, and in the future more features for recovery, transactions, and more.</p>
<pre data-lang="Rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-Rust "><code class="language-Rust" data-lang="Rust"><span style="color:#b48ead;">pub struct </span><span>PageHeader {
</span><span>    </span><span style="color:#b48ead;">pub </span><span style="color:#bf616a;">page_id</span><span>: </span><span style="color:#b48ead;">u32</span><span>,          </span><span style="color:#65737e;">// Unique page identifier
</span><span>    </span><span style="color:#b48ead;">pub </span><span style="color:#bf616a;">page_type</span><span>: PageType,   </span><span style="color:#65737e;">// Data, Index, Overflow, or Free
</span><span>    </span><span style="color:#b48ead;">pub </span><span style="color:#bf616a;">free_space_start</span><span>: </span><span style="color:#b48ead;">u16</span><span>, </span><span style="color:#65737e;">// Where slot array ends
</span><span>    </span><span style="color:#b48ead;">pub </span><span style="color:#bf616a;">free_space_end</span><span>: </span><span style="color:#b48ead;">u16</span><span>,   </span><span style="color:#65737e;">// Where record data begins
</span><span>    </span><span style="color:#b48ead;">pub </span><span style="color:#bf616a;">slot_count</span><span>: </span><span style="color:#b48ead;">u16</span><span>,       </span><span style="color:#65737e;">// Number of slots
</span><span>    </span><span style="color:#65737e;">//pub lsn: u64,              // will be explained in future blogs
</span><span>    </span><span style="color:#b48ead;">pub </span><span style="color:#bf616a;">checksum</span><span>: </span><span style="color:#b48ead;">u32</span><span>,         </span><span style="color:#65737e;">// Data integrity check
</span><span>}
</span></code></pre>
<p>The page types are as follows:</p>
<ul>
<li>Data - pretty self explanatory but these pages actually hold regular records (the only type we'll focus on in this blog)</li>
<li>Index - these form the internal nodes of the B/B+ Tree Index</li>
</ul>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>         [Index Page]
</span><span>        /     |      \
</span><span>   [Index] [Index] [Index]    &lt;- More index pages
</span><span>      |       |       |
</span><span>   [Data]  [Data]  [Data]      &lt;- Leaf level (data pages)
</span></code></pre>
<ul>
<li>Overflow - when we have a record that is too big to fit in a page we use the Overflow page for it, Overflow pages can be chained together to hold large values/records.</li>
<li>Free - unused pages available for allocation, usually deleted pages which can then be later used for space reclamation.</li>
</ul>
<h3 id="the-slotted-page-design-data-page">The Slotted Page Design (Data Page)</h3>
<p>Important Note: for now records are just an array of bytes (raw data).</p>
<p>Slotted page is a type of page architecture that brings flexibility and time efficiency letting you add variable sized records without worrying about where they should go in the page. Imagine we just add variable sized records to a page - the first one is easy to add</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>| ------- 8KB ------- | // an empty page
</span><span>| R1 ---- | 7.85KB ----- | // 1 record
</span></code></pre>
<p>Now to add another record we need to find where the first record ends which sounds simple but once we need to add more records each action will require us to iterate over all the records for each one, find where it ends and move to the next one</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>| -R1- --R2-- -----R3----- -R4- | // variable sized records
</span></code></pre>
<p>To fetch R3 we need to find where it starts which is where R2 ends and the size of R3, but to find where R2 ends we need to find where it starts and its size, and to find where R2 starts we need to find where R1 ends. Suddenly this simple operation requires us to go over the entire page.
The slotted page design comes to solve this issue - records are being added from the end of the page towards the start and for each record we add a slot (from the start towards the end)</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>| -S1- -S2- ----- R2 R1 |
</span></code></pre>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>┌─────────────────────────────────────────────────────────────────┐
</span><span>│ Header (64 bytes)                                               │
</span><span>├─────────────────────────────────────────────────────────────────┤
</span><span>│ Slot Array (grows →)                                            │
</span><span>│ [Slot 0][Slot 1][Slot 2]...                                     │
</span><span>├─────────────────────────────────────────────────────────────────┤
</span><span>│                                                                 │
</span><span>│                    FREE SPACE                                   │
</span><span>│                                                                 │
</span><span>├─────────────────────────────────────────────────────────────────┤
</span><span>│ Records (← grows backward from end)                             │
</span><span>│ ...][Record 2][Record 1][Record 0]                              │
</span><span>└─────────────────────────────────────────────────────────────────┘
</span></code></pre>
<p>Slots are fixed size and they contain information about the record. Since they are fixed sized it's easy to locate slot number X with pointer arithmetic</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">pub fn </span><span style="color:#8fa1b3;">get_slot</span><span>(&amp;</span><span style="color:#bf616a;">self</span><span>, </span><span style="color:#bf616a;">index</span><span>: </span><span style="color:#b48ead;">usize</span><span>) -&gt; Option&lt;SlotEntry&gt; {
</span><span>        </span><span style="color:#b48ead;">if</span><span> index &gt;= </span><span style="color:#bf616a;">self</span><span>.</span><span style="color:#96b5b4;">header</span><span>().slot_count as </span><span style="color:#b48ead;">usize </span><span>{
</span><span>            </span><span style="color:#b48ead;">return </span><span>None;
</span><span>        }
</span><span>
</span><span>        </span><span style="color:#b48ead;">let</span><span> slot_offset = </span><span style="color:#b48ead;">Self</span><span>::</span><span style="color:#d08770;">HEADER_SIZE </span><span>+ (index * </span><span style="color:#b48ead;">Self</span><span>::</span><span style="color:#d08770;">SLOT_SIZE</span><span>);
</span><span>        </span><span style="color:#b48ead;">if</span><span> slot_offset + </span><span style="color:#b48ead;">Self</span><span>::</span><span style="color:#d08770;">SLOT_SIZE </span><span>&gt; </span><span style="color:#d08770;">PAGE_SIZE </span><span>{
</span><span>            </span><span style="color:#b48ead;">return </span><span>None;
</span><span>        }
</span><span>        </span><span style="color:#b48ead;">unsafe </span><span>{
</span><span>            Some(*(</span><span style="color:#bf616a;">self</span><span>.data.</span><span style="color:#96b5b4;">as_ptr</span><span>().</span><span style="color:#96b5b4;">add</span><span>(slot_offset) as </span><span style="color:#b48ead;">*const</span><span> SlotEntry))
</span><span>        }
</span><span>    }
</span></code></pre>
<p>Note: there is a logical proof of safety (which is recommended for any unsafe use) in the GitHub repo. This is possible to do without the use of unsafe but will impact performance and code complexity.</p>
<p>Once we got the slot we know the record location and size</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">pub struct </span><span>SlotEntry {
</span><span>    </span><span style="color:#b48ead;">pub </span><span style="color:#bf616a;">offset</span><span>: </span><span style="color:#b48ead;">u16</span><span>, </span><span style="color:#65737e;">// 2 bytes - offset from start of page
</span><span>    </span><span style="color:#b48ead;">pub </span><span style="color:#bf616a;">length</span><span>: </span><span style="color:#b48ead;">u16</span><span>, </span><span style="color:#65737e;">// 2 bytes - length of record
</span><span>}
</span></code></pre>
<p>which makes it easy to fetch the record</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">pub fn </span><span style="color:#8fa1b3;">get_record</span><span>(&amp;</span><span style="color:#bf616a;">self</span><span>, </span><span style="color:#bf616a;">slot_index</span><span>: </span><span style="color:#b48ead;">usize</span><span>) -&gt; Option&lt;&amp;[</span><span style="color:#b48ead;">u8</span><span>]&gt; {
</span><span>        </span><span style="color:#b48ead;">let</span><span> slot = </span><span style="color:#bf616a;">self</span><span>.</span><span style="color:#96b5b4;">get_slot</span><span>(slot_index)?;
</span><span>
</span><span>        </span><span style="color:#b48ead;">if</span><span> slot.length == </span><span style="color:#d08770;">0 </span><span>{
</span><span>            </span><span style="color:#b48ead;">return </span><span>None; </span><span style="color:#65737e;">// Deleted record
</span><span>        }
</span><span>
</span><span>        </span><span style="color:#b48ead;">let</span><span> start = slot.offset as </span><span style="color:#b48ead;">usize</span><span>;
</span><span>        </span><span style="color:#b48ead;">let</span><span> end = start + slot.length as </span><span style="color:#b48ead;">usize</span><span>;
</span><span>
</span><span>        </span><span style="color:#b48ead;">if</span><span> end &lt;= </span><span style="color:#d08770;">PAGE_SIZE </span><span>{
</span><span>            Some(&amp;</span><span style="color:#bf616a;">self</span><span>.data[start..end])
</span><span>        } </span><span style="color:#b48ead;">else </span><span>{
</span><span>            None
</span><span>        }
</span><span>    }
</span></code></pre>
<h3 id="deletion-and-compaction">Deletion and Compaction</h3>
<p>Now that we know how pages are built, what happens when we delete a record?
The act of deleting a record is simple - we just mark the slot as deleted and not actually remove it and reclaim the space since this is a costly action to do. We should avoid reclaiming small amounts of space and only do this action when we have a meaningful amount to reclaim.</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">pub fn </span><span style="color:#8fa1b3;">delete_record</span><span>(&amp;</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span>, </span><span style="color:#bf616a;">slot_index</span><span>: </span><span style="color:#b48ead;">usize</span><span>) -&gt; </span><span style="color:#b48ead;">bool </span><span>{
</span><span>        </span><span style="color:#b48ead;">if let </span><span>Some(</span><span style="color:#b48ead;">mut</span><span> slot) = </span><span style="color:#bf616a;">self</span><span>.</span><span style="color:#96b5b4;">get_slot</span><span>(slot_index) {
</span><span>            slot.length = </span><span style="color:#d08770;">0</span><span>;
</span><span>            </span><span style="color:#bf616a;">self</span><span>.</span><span style="color:#96b5b4;">set_slot</span><span>(slot_index, slot);
</span><span>            </span><span style="color:#65737e;">// Note: We don&#39;t reclaim space yet - that would require compaction
</span><span>            </span><span style="color:#d08770;">true
</span><span>        } </span><span style="color:#b48ead;">else </span><span>{
</span><span>            </span><span style="color:#d08770;">false
</span><span>        }
</span><span>    }
</span></code></pre>
<p>We just set the slot length to 0 which marks a deleted record. The data itself still exists but we ignore it since we actually know all the existing records and how to fetch them.</p>
<p>Now the question is when to compact? The answer is complicated. First, I'd like to make this customizable in the future since what works for one is not the solution for another. Second, to find an optimal number of when to compact we need a lot of usage to get statistics from, so for now I just picked 20% of the page size and at least 2 deleted records.</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">pub fn </span><span style="color:#8fa1b3;">should_compact</span><span>(&amp;</span><span style="color:#bf616a;">self</span><span>) -&gt; </span><span style="color:#b48ead;">bool </span><span>{
</span><span>        </span><span style="color:#b48ead;">let</span><span> total_slots = </span><span style="color:#bf616a;">self</span><span>.</span><span style="color:#96b5b4;">header</span><span>().slot_count as </span><span style="color:#b48ead;">usize</span><span>;
</span><span>
</span><span>        </span><span style="color:#65737e;">// Don&#39;t compact empty pages or pages with very few slots
</span><span>        </span><span style="color:#b48ead;">if</span><span> total_slots &lt;= </span><span style="color:#d08770;">1 </span><span>{
</span><span>            </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">false</span><span>;
</span><span>        }
</span><span>
</span><span>        </span><span style="color:#b48ead;">let</span><span> deleted = </span><span style="color:#bf616a;">self</span><span>.</span><span style="color:#96b5b4;">deleted_count</span><span>();
</span><span>
</span><span>        </span><span style="color:#65737e;">// Need at least 2 deleted slots AND &gt; 20% deleted
</span><span>        deleted &gt;= </span><span style="color:#d08770;">2 </span><span>&amp;&amp; (deleted * </span><span style="color:#d08770;">100 </span><span>/ total_slots) &gt; </span><span style="color:#d08770;">20
</span><span>    }
</span></code></pre>
<p>The actual compaction is a process where we move the slots towards the end of the page and the records towards the beginning of it, overwriting the deleted ones.</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">pub fn </span><span style="color:#8fa1b3;">compact</span><span>(&amp;</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span>) {
</span><span>        </span><span style="color:#b48ead;">if </span><span>!</span><span style="color:#bf616a;">self</span><span>.</span><span style="color:#96b5b4;">should_compact</span><span>() {
</span><span>            </span><span style="color:#b48ead;">return</span><span>;
</span><span>        }
</span><span>
</span><span>        </span><span style="color:#b48ead;">let</span><span> old_slot_count = </span><span style="color:#bf616a;">self</span><span>.</span><span style="color:#96b5b4;">header</span><span>().slot_count as </span><span style="color:#b48ead;">usize</span><span>;
</span><span>        </span><span style="color:#b48ead;">let mut</span><span> write_position = </span><span style="color:#d08770;">PAGE_SIZE</span><span>;
</span><span>        </span><span style="color:#b48ead;">let mut</span><span> write_slot_index = </span><span style="color:#d08770;">0</span><span>;
</span><span>
</span><span>        </span><span style="color:#65737e;">// Two-pass in-place compaction
</span><span>        </span><span style="color:#b48ead;">for</span><span> read_slot_index in </span><span style="color:#d08770;">0</span><span>..old_slot_count {
</span><span>            </span><span style="color:#b48ead;">if let </span><span>Some(slot) = </span><span style="color:#bf616a;">self</span><span>.</span><span style="color:#96b5b4;">get_slot</span><span>(read_slot_index) {
</span><span>                </span><span style="color:#b48ead;">if</span><span> slot.length &gt; </span><span style="color:#d08770;">0 </span><span>{  </span><span style="color:#65737e;">// Active slot
</span><span>                    </span><span style="color:#b48ead;">let</span><span> record_len = slot.length as </span><span style="color:#b48ead;">usize</span><span>;
</span><span>                    </span><span style="color:#b48ead;">let</span><span> old_start = slot.offset as </span><span style="color:#b48ead;">usize</span><span>;
</span><span>                    </span><span style="color:#b48ead;">let</span><span> old_end = old_start + record_len;
</span><span>
</span><span>                    </span><span style="color:#65737e;">// Calculate new position for record (growing backwards from end)
</span><span>                    </span><span style="color:#b48ead;">let</span><span> new_start = write_position - record_len;
</span><span>
</span><span>                    </span><span style="color:#65737e;">// Move record data if needed
</span><span>                    </span><span style="color:#b48ead;">if</span><span> new_start != old_start {
</span><span>                        </span><span style="color:#bf616a;">self</span><span>.data.</span><span style="color:#96b5b4;">copy_within</span><span>(old_start..old_end, new_start);
</span><span>                    }
</span><span>
</span><span>                    </span><span style="color:#65737e;">// Always write the compacted slot (simpler, clearer)
</span><span>                    </span><span style="color:#bf616a;">self</span><span>.</span><span style="color:#96b5b4;">set_slot</span><span>(write_slot_index, SlotEntry {
</span><span>                        offset: new_start as </span><span style="color:#b48ead;">u16</span><span>,
</span><span>                        length: slot.length,
</span><span>                    });
</span><span>
</span><span>                    write_position = new_start;
</span><span>                    write_slot_index += </span><span style="color:#d08770;">1</span><span>;
</span><span>                }
</span><span>            }
</span><span>        }
</span><span>
</span><span>        </span><span style="color:#65737e;">// Update header with new counts and free space boundary
</span><span>        </span><span style="color:#b48ead;">let</span><span> header = </span><span style="color:#bf616a;">self</span><span>.</span><span style="color:#96b5b4;">header_mut</span><span>();
</span><span>        header.free_space_end = write_position as </span><span style="color:#b48ead;">u16</span><span>;
</span><span>        header.slot_count = write_slot_index as </span><span style="color:#b48ead;">u16</span><span>;  </span><span style="color:#65737e;">// Only active slots
</span><span>    }
</span></code></pre>
<p>Let's walk through this compaction algorithm.</p>
<p>Before compaction our page looks like</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>       Slot Array                              Records Area
</span><span>┌───┬───┬───┬───┬───┐                    ┌───────────────────────┐
</span><span>│ 0 │ 1 │ 2 │ 3 │ 4 │                    │...][E][D][C][B][A]    │
</span><span>│ptr│DEL│ptr│DEL│ptr│                    │   ↑     ↑     ↑       │
</span><span>└─┬─┴───┴─┬─┴───┴─┬─┘                    │   │     │     │       │
</span><span>  │       │       │                      │   │     │     └── Slot 0 points here
</span><span>  │       │       └──────────────────────┼───┼─────┘
</span><span>  │       └──────────────────────────────┼───┘
</span><span>  └──────────────────────────────────────┘
</span><span>
</span><span>Fragmentation: Records B and D are orphaned (slots deleted)
</span></code></pre>
<p>Let's break the algorithm into steps</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>Pass through slots 0-4:
</span><span>
</span><span>Slot 0 (active &quot;A&quot;):  Move to end        → write_position = PAGE_SIZE - 5
</span><span>Slot 1 (deleted):     Skip
</span><span>Slot 2 (active &quot;C&quot;):  Move next          → write_position -= len(C)
</span><span>Slot 3 (deleted):     Skip  
</span><span>Slot 4 (active &quot;E&quot;):  Move next          → write_position -= len(E)
</span><span>
</span><span>Rewrite slot array with only active slots (indices 0, 1, 2)
</span></code></pre>
<p>Now after compaction let's visualize the page again</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>       Slot Array                              Records Area
</span><span>┌───┬───┬───┐                            ┌───────────────────────┐
</span><span>│ 0 │ 1 │ 2 │                            │         ][E][C][A]    │
</span><span>│ptr│ptr│ptr│                            │           ↑  ↑  ↑     │
</span><span>└─┬─┴─┬─┴─┬─┘                            │           │  │  │     │
</span><span>  │   │   └──────────────────────────────┼───────────┼──┼──┘
</span><span>  │   └──────────────────────────────────┼───────────┼──┘
</span><span>  └──────────────────────────────────────┼───────────┘
</span><span>                                         │
</span><span>                              free_space_end (more free space!)
</span></code></pre>
<p>Now we are left with 3 records and slots, everything is continuous with no fragmentation and we reclaimed the unused space of deleted records.</p>
<p>That's it! We are almost finished with the Page unit of this database. All that's left is implementing an iterator which I promise is less complex than what we've been through.</p>
<h3 id="iterators">Iterators</h3>
<p>In Rust an iterator is an object that implements the <code>Iterator</code> trait</p>
<pre data-lang="Rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-Rust "><code class="language-Rust" data-lang="Rust"><span style="color:#b48ead;">pub trait </span><span>Iterator {
</span><span>    </span><span style="color:#b48ead;">type </span><span>Item;
</span><span>
</span><span>    </span><span style="color:#65737e;">// Required method
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">next</span><span>(&amp;</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span>) -&gt; Option&lt;</span><span style="color:#b48ead;">Self::</span><span>Item&gt;;
</span><span>
</span><span>    ... </span><span style="color:#d08770;">75</span><span> more methods
</span><span>}
</span></code></pre>
<p>With the goal of iterating over another object, so for that we create the <code>PageIterator</code></p>
<pre data-lang="Rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-Rust "><code class="language-Rust" data-lang="Rust"><span style="color:#b48ead;">pub struct </span><span>PageIterator&lt;</span><span style="color:#b48ead;">&#39;a</span><span>&gt; {
</span><span>    </span><span style="color:#bf616a;">page</span><span>: &amp;</span><span style="color:#b48ead;">&#39;a</span><span> Page,
</span><span>    </span><span style="color:#bf616a;">current_slot</span><span>: </span><span style="color:#b48ead;">usize</span><span>,
</span><span>}
</span></code></pre>
<p>Now let's implement the <code>Iterator</code> trait with the required function to get the next item</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">impl</span><span>&lt;</span><span style="color:#b48ead;">&#39;a</span><span>&gt; Iterator </span><span style="color:#b48ead;">for </span><span>PageIterator&lt;</span><span style="color:#b48ead;">&#39;a</span><span>&gt; {
</span><span>    </span><span style="color:#b48ead;">type </span><span>Item = &amp;</span><span style="color:#b48ead;">&#39;a </span><span>[</span><span style="color:#b48ead;">u8</span><span>];
</span><span>
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">next</span><span>(&amp;</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span>) -&gt; Option&lt;</span><span style="color:#b48ead;">Self::</span><span>Item&gt; {
</span><span>        </span><span style="color:#b48ead;">while </span><span style="color:#bf616a;">self</span><span>.current_slot &lt; </span><span style="color:#bf616a;">self</span><span>.page.</span><span style="color:#96b5b4;">header</span><span>().slot_count as </span><span style="color:#b48ead;">usize </span><span>{
</span><span>            </span><span style="color:#b48ead;">let</span><span> slot_index = </span><span style="color:#bf616a;">self</span><span>.current_slot;
</span><span>            </span><span style="color:#bf616a;">self</span><span>.current_slot += </span><span style="color:#d08770;">1</span><span>;
</span><span>
</span><span>            </span><span style="color:#b48ead;">if let </span><span>Some(record) = </span><span style="color:#bf616a;">self</span><span>.page.</span><span style="color:#96b5b4;">get_record</span><span>(slot_index) {
</span><span>                </span><span style="color:#b48ead;">return </span><span>Some(record);
</span><span>            }
</span><span>        }
</span><span>        None
</span><span>    }
</span><span>}
</span></code></pre>
<p>Now we're halfway there. The only thing required from us is a way to turn the <code>Page</code> into a <code>PageIterator</code></p>
<pre data-lang="Rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-Rust "><code class="language-Rust" data-lang="Rust"><span style="color:#b48ead;">impl </span><span>Page {
</span><span>   </span><span style="color:#b48ead;">pub fn </span><span style="color:#8fa1b3;">iter</span><span>(&amp;</span><span style="color:#bf616a;">self</span><span>) -&gt; PageIterator {
</span><span>        PageIterator {
</span><span>            page: </span><span style="color:#bf616a;">self</span><span>,
</span><span>            current_slot: </span><span style="color:#d08770;">0</span><span>,
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre>
<p>As simple as that!</p>
<p>And that's it y'all! With the first practical part of this blog series where we covered the very basics of the storage layer - the Page. In the next entries we will go over file storage, indexing, records and a lot more so stay tuned and see you soon!</p>

        </div>
        
        <footer class="post-footer">
            <a href="/blog" class="back-link">← Back to Blog</a>
        </footer>
    </div>
</article>

    </main>

    <footer>
        <div class="footer-container">
            <p>&copy; 2024 Jonathan Sarig</p>
        </div>
    </footer>

    <script src="https://jon-s58.github.io/scripts/spaceships.js"></script>
</body>
</html>
